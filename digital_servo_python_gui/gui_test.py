# -*- coding: utf-8 -*-
"""
Phase-lock box main GUI test script,
by JD Deschenes, August 2019

"""
from __future__ import print_function
import sys
from PyQt5 import QtGui, Qt, QtCore, QtWidgets
import numpy as np
import pytest

import time
import pdb

from SLLSystemParameters import SLLSystemParameters
from SuperLaserLand_mock import SuperLaserLand_mock
from XEM_GUI_MainWindow import XEM_GUI_MainWindow

from TestHelpers import *

import RP_PLL

#sys._excepthook = sys.excepthook
#def exception_hook(exctype, value, traceback):
#   print("exception_hook(): type = %s, value = %s" % (exctype, value))
#   
#   sys._excepthook(exctype, value, traceback)
#   sys.exit(1)
#sys.excepthook = exception_hook


class PlotWindowIntercept():
    # intercept the 'outputs' of various functions for testing
    def __init__(self, obj_to_replace):
        self.obj = obj_to_replace
        self.bVisible = -1
        self.x = np.array([-1])
        self.y = np.array([-1])
        pass
    def setData(self, x, y):
        self.x = x
        self.y = y
        self.obj.setData(x, y)

    def setVisible(self, bVisible):
        self.bVisible = bVisible
        self.obj.setVisible(bVisible)

class PlotWidgetIntercept():
    # intercept the 'outputs' of various functions for testing
    def __init__(self, obj_to_replace):
        self.obj = obj_to_replace
        self.bReplotCalls = 0
        self.xmin_val = -1
        self.xmax_val = -1
        self.ymin_val = -1
        self.ymax_val = -1
        pass
    def setXRange(self, min_val, max_val):
        self.xmin_val = min_val
        self.xmax_val = max_val
        self.obj.setXRange(min_val, max_val)
    def setYRange(self, min_val, max_val):
        self.ymin_val = min_val
        self.ymax_val = max_val
        self.obj.setYRange(min_val, max_val)

    def setLabel(self, *args, **kwargs):
        pass

    def getPlotItem(self):
        # class PlotItemMock():
        #     def setLogMode(self, *args, **kwargs):
        #         pass
        # obj = PlotItemMock()
        return self.obj.getPlotItem()

    def replot(self):
        self.bReplotCalls += 1
        self.obj.replot()

    def setTitle(self, strTitle):
        self.strTitle = strTitle
        self.obj.setTitle(strTitle)

def print_all_state(g):
# this is used to determine what the "true" outputs should be
    
    print("--------------------- Output state -------------------")
    print("g.filtered_baseband_snr = %f" % g.filtered_baseband_snr)

    # GUI-based outputs:
    print("g.qadc0_scale.value = %f" % g.qadc0_scale.value)
    print("g.qthermo_baseband_snr.value = %f" % g.qthermo_baseband_snr.value)
    print("g.qthermo_baseband_snr.value = %f" % g.qthermo_baseband_snr.value)

    print("g.qlabel_adc_fill_value.text() = %s" % g.qlabel_adc_fill_value.text())
    print("g.qlabel_rawdata_rbw.text() = %s" % g.qlabel_rawdata_rbw.text())
    print("g.qlabel_baseband_snr_value.text() = %s" % g.qlabel_baseband_snr_value.text())

    # "outputs" that were really calls to the plotting library (that we intercepted) or their effects:
    print("g.qplt_IQ.xmin_val = %f" % g.qplt_IQ.xmin_val)
    print("g.qplt_IQ.xmax_val = %f" % g.qplt_IQ.xmax_val)
    print("g.qplt_IQ.ymin_val = %f" % g.qplt_IQ.ymin_val)
    print("g.qplt_IQ.ymax_val = %f" % g.qplt_IQ.ymax_val)
    print("g.qplt_IQ.bReplotCalls = %d" % g.qplt_IQ.bReplotCalls)

    print("g.plt_spc.xmin_val = %f" % g.plt_spc.xmin_val)
    print("g.plt_spc.xmax_val = %f" % g.plt_spc.xmax_val)
    print("g.plt_spc.ymin_val = %f" % g.plt_spc.ymin_val)
    print("g.plt_spc.ymax_val = %f" % g.plt_spc.ymax_val)
    print("g.plt_spc.bReplotCalls = %d" % g.plt_spc.bReplotCalls)
    print("g.plt_spc.strTitle = %s" % g.plt_spc.strTitle)

    print("g.curve_spc.bVisible = %d" % g.curve_spc.bVisible)
    print("g.curve_filter.bVisible = %d" % g.curve_filter.bVisible)
    print("g.curve_IQ.bVisible = %d" % g.curve_IQ.bVisible)

    decimals = 9
    print("g.curve_spc.x = %s" % np.round(g.curve_spc.x, decimals=decimals).tolist())
    print("g.curve_filter.x = %s" % np.round(g.curve_filter.x, decimals=decimals).tolist())
    print("g.curve_IQ.x = %s" % np.round(g.curve_IQ.x, decimals=decimals).tolist())

    print("g.curve_spc.y = %s" % np.round(g.curve_spc.y, decimals=decimals).tolist())
    print("g.curve_filter.y = %s" % np.round(g.curve_filter.y, decimals=decimals).tolist())
    print("g.curve_IQ.y = %s" % np.round(g.curve_IQ.y, decimals=decimals).tolist())

    # internal state output variables
    print("raw_adc_samples = %s" % repr(g.parent.raw_adc_samples.tolist()))
    print("self.sl.bDDR2InUse = %s" % repr(g.parent.sl.bDDR2InUse))
    print("------------------ End output state -------------------")


def check_grabAndDisplayADC_outputs(g, test_number=0):
    bPass = True
    strFailedFields = ''
    # print("check_grabAndDisplayADC_outputs(): test_number=%d" % test_number)

    expected = simple_struct()
    expected.curve_spc                      = simple_struct()
    expected.curve_filter                   = simple_struct()
    expected.curve_IQ                       = simple_struct()
    expected.parent                         = simple_struct()

    if test_number == 0:

        expected_outputs_as_text = """g.filtered_baseband_snr = 4.090108
g.qadc0_scale.value = 11.705200
g.qthermo_baseband_snr.value = 42.980217
g.qthermo_baseband_snr.value = 42.980217
g.qlabel_adc_fill_value.text() = 11.7 bits
g.qlabel_rawdata_rbw.text() = RBW: 2.2 MHz; Points:
g.qlabel_baseband_snr_value.text() = 4.09 dB
g.qplt_IQ.xmin_val = -2253.596044
g.qplt_IQ.xmax_val = 2253.596044
g.qplt_IQ.ymin_val = -2253.596044
g.qplt_IQ.ymax_val = 2253.596044
g.qplt_IQ.bReplotCalls = 0
g.plt_spc.xmin_val = -1.000000
g.plt_spc.xmax_val = -1.000000
g.plt_spc.ymin_val = -1.000000
g.plt_spc.ymax_val = -1.000000
g.plt_spc.bReplotCalls = 0
g.plt_spc.strTitle = Spectrum, noise floor = 130 nV/sqrt(Hz)
g.curve_spc.bVisible = -1
g.curve_filter.bVisible = 1
g.curve_IQ.bVisible = -1
g.parent.sl.bDDR2InUse = False"""

        expected.parent.raw_adc_samples           = np.array([3335.0, 1026.0, -2619.0, -2578.0, 1074.0, 3245.0, 1044.0, -2656.0, -2654.0, 1026.0, 3282.0, 1060.0, -2626.0, -2647.0, 1027.0, 3288.0, 1062.0, -2658.0, -2641.0, 985.0, 3193.0, 1034.0, -2623.0, -2675.0, 1087.0, 3229.0, 1014.0, -2657.0, -2601.0, 1061.0, 3282.0, 1025.0, -2680.0, -2716.0, 1001.0, 3282.0, 1053.0, -2612.0, -2664.0, 1003.0, 3242.0, 966.0, -2707.0, -2587.0, 996.0, 3262.0, 972.0, -2626.0, -2704.0, 1006.0, 3247.0, 1025.0, -2668.0, -2690.0, 1012.0, 3291.0, 1015.0, -2641.0, -2672.0, 1001.0, 3255.0, 1001.0, -2678.0, -2708.0, 1018.0, 3264.0, 959.0, -2636.0, -2681.0, 1014.0, 3301.0, 1017.0, -2614.0, -2691.0, 1026.0, 3254.0, 984.0, -2670.0, -2661.0, 1014.0, 3239.0, 1042.0, -2636.0, -2701.0, 1061.0, 3339.0, 1051.0, -2657.0, -2686.0, 1047.0, 3264.0, 1053.0, -2644.0, -2619.0, 1024.0, 3300.0, 1013.0, -2592.0, -2647.0, 1026.0])
        expected.curve_spc.x                      = np.array([0.0, 0.97656, 1.95312, 2.92969, 3.90625, 4.88281, 5.85938, 6.83594, 7.8125, 8.78906, 9.76562, 10.74219, 11.71875, 12.69531, 13.67188, 14.64844, 15.625, 16.60156, 17.57812, 18.55469, 19.53125, 20.50781, 21.48438, 22.46094, 23.4375, 24.41406, 25.39062, 26.36719, 27.34375, 28.32031, 29.29688, 30.27344, 31.25, 32.22656, 33.20312, 34.17969, 35.15625, 36.13281, 37.10938, 38.08594, 39.0625, 40.03906, 41.01562, 41.99219, 42.96875, 43.94531, 44.92188, 45.89844, 46.875, 47.85156, 48.82812, 49.80469, 50.78125, 51.75781, 52.73438, 53.71094, 54.6875, 55.66406, 56.64062, 57.61719, 58.59375, 59.57031, 60.54688, 61.52344])
        expected.curve_filter.x                   = np.array([0.0, 0.97656, 1.95312, 2.92969, 3.90625, 4.88281, 5.85938, 6.83594, 7.8125, 8.78906, 9.76562, 10.74219, 11.71875, 12.69531, 13.67188, 14.64844, 15.625, 16.60156, 17.57812, 18.55469, 19.53125, 20.50781, 21.48438, 22.46094, 23.4375, 24.41406, 25.39062, 26.36719, 27.34375, 28.32031, 29.29688, 30.27344, 31.25, 32.22656, 33.20312, 34.17969, 35.15625, 36.13281, 37.10938, 38.08594, 39.0625, 40.03906, 41.01562, 41.99219, 42.96875, 43.94531, 44.92188, 45.89844, 46.875, 47.85156, 48.82812, 49.80469, 50.78125, 51.75781, 52.73438, 53.71094, 54.6875, 55.66406, 56.64062, 57.61719, 58.59375, 59.57031, 60.54688, 61.52344])
        expected.curve_IQ.x                       = np.array([-682.75, -221.75, 238.0, 696.5, 1058.9375, 1325.3125, 1457.375, 1455.125, 1322.375, 1059.125, 700.1875, 245.5625, -212.25, -673.25, -1045.5, -1329.0, -1475.6875, -1485.5625, -1347.9375, -1062.8125, -686.9375, -220.3125, 242.0625, 700.1875, 1066.0625, 1339.6875, 1479.1875, 1484.5625, 1346.875, 1066.125, 695.8125, 235.9375, -225.25, -687.75, -1061.1875, -1345.5625, -1485.5, -1481.0, -1339.0625, -1059.6875, -689.8125, -229.4375, 231.0, 691.5, 1061.75, 1341.75, 1482.125, 1482.875, 1343.4375, 1063.8125, 696.6875, 242.0625, -216.4375, -678.8125, -1056.375, -1349.125, -1491.3125, -1482.9375, -1336.5625, -1052.1875, -685.125, -235.375, 219.9375, 680.8125, 1052.1875, 1334.0625, 1473.4375, 1470.3125, 1332.625, 1060.375, 693.8125, 232.9375, -231.6875, -700.0625, -1072.5625, -1349.1875, -1484.875, -1479.625, -1337.0, -1057.0, -688.4375, -231.3125, 226.6875, 685.5625])
        expected.curve_spc.y                      = np.array([-64.22699, -64.83509, -67.84623, -75.48803, -81.5468, -76.74014, -74.71705, -76.16352, -73.42712, -71.75851, -78.83173, -74.59189, -72.21241, -72.91381, -71.28263, -70.15879, -71.3752, -71.02669, -66.36323, -66.0372, -71.00377, -71.49449, -73.7469, -40.6583, -27.02014, -20.94037, -20.41725, -25.32163, -37.17166, -64.94342, -74.56989, -69.63431, -70.95632, -70.83889, -71.07941, -71.37079, -70.22647, -71.51792, -73.06263, -76.93013, -80.461, -74.31023, -71.7724, -72.32836, -75.68827, -81.08281, -79.89384, -73.33646, -75.58199, -81.94307, -69.98806, -68.79773, -77.28515, -72.98241, -73.7475, -79.45892, -74.27932, -73.732, -73.52134, -72.6101, -70.61511, -67.73285, -67.34467, -69.11381])
        expected.curve_filter.y                   = np.array([-132.77712, -37.15543, -30.38523, -26.15526, -22.98854, -20.42147, -18.24703, -16.35441, -14.67717, -13.17224, -11.81004, -10.56937, -9.43444, -8.39321, -7.43626, -6.55608, -5.7466, -5.00284, -4.32066, -3.69662, -3.12781, -2.61177, -2.14641, -1.72996, -1.36091, -1.03799, -0.76013, -0.52643, -0.33617, -0.18877, -0.0838, -0.02093, 0.0, -0.02093, -0.0838, -0.18877, -0.33617, -0.52643, -0.76013, -1.03799, -1.36091, -1.72996, -2.14641, -2.61177, -3.12781, -3.69662, -4.32066, -5.00284, -5.7466, -6.55608, -7.43626, -8.39321, -9.43444, -10.56937, -11.81004, -13.17224, -14.67717, -16.35441, -18.24703, -20.42147, -22.98854, -26.15526, -30.38523, -37.15543])
        expected.curve_IQ.y                       = np.array([1344.5, 1484.4375, 1485.8125, 1342.5625, 1054.6875, 680.0, 218.5, -241.0, -698.5, -1064.4375, -1338.8125, -1474.875, -1472.625, -1336.0, -1065.0, -699.375, -239.125, 227.0625, 699.1875, 1076.3125, 1358.4375, 1493.0, 1480.0, 1331.0625, 1046.1875, 680.125, 232.875, -215.125, -663.875, -1031.75, -1318.75, -1464.6875, -1469.5625, -1331.0, -1049.0, -679.8125, -223.4375, 235.75, 697.75, 1070.375, 1353.625, 1492.1875, 1486.0625, 1339.875, 1053.625, 682.875, 227.625, -231.8125, -695.4375, -1068.6875, -1351.5625, -1488.5, -1479.5, -1334.375, -1053.125, -684.1875, -227.5625, 232.3125, 695.4375, 1066.8125, 1346.4375, 1484.9375, 1482.3125, 1341.0, 1061.0, 689.0, 225.0, -239.1875, -703.5625, -1079.3125, -1366.4375, -1507.25, -1501.75, -1355.75, -1069.25, -694.125, -230.375, 230.625, 688.875, 1058.4375, 1339.3125, 1478.0625, 1474.6875, 1330.875])
    elif test_number == 1:

        expected_outputs_as_text = """g.filtered_baseband_snr = 4.090108
g.qadc0_scale.value = 11.705200
g.qthermo_baseband_snr.value = 42.980217
g.qthermo_baseband_snr.value = 42.980217
g.qlabel_adc_fill_value.text() = 11.7 bits
g.qlabel_rawdata_rbw.text() = RBW: 1.2 MHz; Points:
g.qlabel_baseband_snr_value.text() = 4.09 dB
g.qplt_IQ.xmin_val = -2253.596044
g.qplt_IQ.xmax_val = 2253.596044
g.qplt_IQ.ymin_val = -2253.596044
g.qplt_IQ.ymax_val = 2253.596044
g.qplt_IQ.bReplotCalls = 0
g.plt_spc.xmin_val = 0.000000
g.plt_spc.xmax_val = 0.000001
g.plt_spc.ymin_val = -0.092140
g.plt_spc.ymax_val = 0.111153
g.plt_spc.bReplotCalls = 0
g.plt_spc.strTitle = Time, std = 70.74 mV, ampl = 200.09 mVpp
g.curve_spc.bVisible = -1
g.curve_filter.bVisible = 0
g.curve_IQ.bVisible = -1
g.parent.sl.bDDR2InUse = False"""

        expected.curve_spc.x = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        expected.curve_filter.x = np.array([-1])
        expected.curve_IQ.x = np.array([-682.75, -221.75, 238.0, 696.5, 1058.9375, 1325.3125, 1457.375, 1455.125, 1322.375, 1059.125, 700.1875, 245.5625, -212.25, -673.25, -1045.5, -1329.0, -1475.6875, -1485.5625, -1347.9375, -1062.8125, -686.9375, -220.3125, 242.0625, 700.1875, 1066.0625, 1339.6875, 1479.1875, 1484.5625, 1346.875, 1066.125, 695.8125, 235.9375, -225.25, -687.75, -1061.1875, -1345.5625, -1485.5, -1481.0, -1339.0625, -1059.6875, -689.8125, -229.4375, 231.0, 691.5, 1061.75, 1341.75, 1482.125, 1482.875, 1343.4375, 1063.8125, 696.6875, 242.0625, -216.4375, -678.8125, -1056.375, -1349.125, -1491.3125, -1482.9375, -1336.5625, -1052.1875, -685.125, -235.375, 219.9375, 680.8125, 1052.1875, 1334.0625, 1473.4375, 1470.3125, 1332.625, 1060.375, 693.8125, 232.9375, -231.6875, -700.0625, -1072.5625, -1349.1875, -1484.875, -1479.625, -1337.0, -1057.0, -688.4375, -231.3125, 226.6875, 685.5625])
        expected.curve_spc.y = np.array([0.10178, 0.03131, -0.07993, -0.07867, 0.03278, 0.09903, 0.03186, -0.08105, -0.08099, 0.03131, 0.10016, 0.03235, -0.08014, -0.08078, 0.03134, 0.10034, 0.03241, -0.08112, -0.0806, 0.03006, 0.09744, 0.03156, -0.08005, -0.08163, 0.03317, 0.09854, 0.03094, -0.08109, -0.07938, 0.03238, 0.10016, 0.03128, -0.08179, -0.08289, 0.03055, 0.10016, 0.03214, -0.07971, -0.0813, 0.03061, 0.09894, 0.02948, -0.08261, -0.07895, 0.0304, 0.09955, 0.02966, -0.08014, -0.08252, 0.0307, 0.09909, 0.03128, -0.08142, -0.08209, 0.03088, 0.10043, 0.03098, -0.0806, -0.08154, 0.03055, 0.09933, 0.03055, -0.08173, -0.08264, 0.03107, 0.09961, 0.02927, -0.08044, -0.08182, 0.03094, 0.10074, 0.03104, -0.07977, -0.08212, 0.03131, 0.0993, 0.03003, -0.08148, -0.08121, 0.03094, 0.09885, 0.0318, -0.08044, -0.08243, 0.03238, 0.1019, 0.03207, -0.08109, -0.08197, 0.03195, 0.09961, 0.03214, -0.08069, -0.07993, 0.03125, 0.10071, 0.03091, -0.0791, -0.08078, 0.03131])
        expected.curve_filter.y = np.array([-1])
        expected.curve_IQ.y = np.array([1344.5, 1484.4375, 1485.8125, 1342.5625, 1054.6875, 680.0, 218.5, -241.0, -698.5, -1064.4375, -1338.8125, -1474.875, -1472.625, -1336.0, -1065.0, -699.375, -239.125, 227.0625, 699.1875, 1076.3125, 1358.4375, 1493.0, 1480.0, 1331.0625, 1046.1875, 680.125, 232.875, -215.125, -663.875, -1031.75, -1318.75, -1464.6875, -1469.5625, -1331.0, -1049.0, -679.8125, -223.4375, 235.75, 697.75, 1070.375, 1353.625, 1492.1875, 1486.0625, 1339.875, 1053.625, 682.875, 227.625, -231.8125, -695.4375, -1068.6875, -1351.5625, -1488.5, -1479.5, -1334.375, -1053.125, -684.1875, -227.5625, 232.3125, 695.4375, 1066.8125, 1346.4375, 1484.9375, 1482.3125, 1341.0, 1061.0, 689.0, 225.0, -239.1875, -703.5625, -1079.3125, -1366.4375, -1507.25, -1501.75, -1355.75, -1069.25, -694.125, -230.375, 230.625, 688.875, 1058.4375, 1339.3125, 1478.0625, 1474.6875, 1330.875])
        expected.parent.raw_adc_samples = np.array([3335.0, 1026.0, -2619.0, -2578.0, 1074.0, 3245.0, 1044.0, -2656.0, -2654.0, 1026.0, 3282.0, 1060.0, -2626.0, -2647.0, 1027.0, 3288.0, 1062.0, -2658.0, -2641.0, 985.0, 3193.0, 1034.0, -2623.0, -2675.0, 1087.0, 3229.0, 1014.0, -2657.0, -2601.0, 1061.0, 3282.0, 1025.0, -2680.0, -2716.0, 1001.0, 3282.0, 1053.0, -2612.0, -2664.0, 1003.0, 3242.0, 966.0, -2707.0, -2587.0, 996.0, 3262.0, 972.0, -2626.0, -2704.0, 1006.0, 3247.0, 1025.0, -2668.0, -2690.0, 1012.0, 3291.0, 1015.0, -2641.0, -2672.0, 1001.0, 3255.0, 1001.0, -2678.0, -2708.0, 1018.0, 3264.0, 959.0, -2636.0, -2681.0, 1014.0, 3301.0, 1017.0, -2614.0, -2691.0, 1026.0, 3254.0, 984.0, -2670.0, -2661.0, 1014.0, 3239.0, 1042.0, -2636.0, -2701.0, 1061.0, 3339.0, 1051.0, -2657.0, -2686.0, 1047.0, 3264.0, 1053.0, -2644.0, -2619.0, 1024.0, 3300.0, 1013.0, -2592.0, -2647.0, 1026.0])



    elif test_number == 2:

        expected_outputs_as_text = """g.filtered_baseband_snr = 4.090108
g.qadc0_scale.value = 11.705200
g.qthermo_baseband_snr.value = 42.980217
g.qthermo_baseband_snr.value = 42.980217
g.qlabel_adc_fill_value.text() = 11.7 bits
g.qlabel_rawdata_rbw.text() = RBW: 1.5 MHz; Points:
g.qlabel_baseband_snr_value.text() = 4.09 dB
g.qplt_IQ.xmin_val = -2253.596044
g.qplt_IQ.xmax_val = 2253.596044
g.qplt_IQ.ymin_val = -2253.596044
g.qplt_IQ.ymax_val = 2253.596044
g.qplt_IQ.bReplotCalls = 0
g.plt_spc.xmin_val = 0.000000
g.plt_spc.xmax_val = 0.000001
g.plt_spc.ymin_val = -26.078289
g.plt_spc.ymax_val = 0.000000
g.plt_spc.bReplotCalls = 0
g.plt_spc.strTitle = Time-domain phase, std = 7.62 radrms
g.curve_spc.bVisible = -1
g.curve_filter.bVisible = 0
g.curve_IQ.bVisible = -1
g.parent.sl.bDDR2InUse = False"""

        expected.curve_spc.x = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        expected.curve_filter.x = np.array([-1])
        expected.curve_IQ.x = np.array([-682.75, -221.75, 238.0, 696.5, 1058.9375, 1325.3125, 1457.375, 1455.125, 1322.375, 1059.125, 700.1875, 245.5625, -212.25, -673.25, -1045.5, -1329.0, -1475.6875, -1485.5625, -1347.9375, -1062.8125, -686.9375, -220.3125, 242.0625, 700.1875, 1066.0625, 1339.6875, 1479.1875, 1484.5625, 1346.875, 1066.125, 695.8125, 235.9375, -225.25, -687.75, -1061.1875, -1345.5625, -1485.5, -1481.0, -1339.0625, -1059.6875, -689.8125, -229.4375, 231.0, 691.5, 1061.75, 1341.75, 1482.125, 1482.875, 1343.4375, 1063.8125, 696.6875, 242.0625, -216.4375, -678.8125, -1056.375, -1349.125, -1491.3125, -1482.9375, -1336.5625, -1052.1875, -685.125, -235.375, 219.9375, 680.8125, 1052.1875, 1334.0625, 1473.4375, 1470.3125, 1332.625, 1060.375, 693.8125, 232.9375, -231.6875, -700.0625, -1072.5625, -1349.1875, -1484.875, -1479.625, -1337.0, -1057.0, -688.4375, -231.3125, 226.6875, 685.5625])
        expected.curve_spc.y = np.array([0.0, -0.32159, -0.62871, -0.94844, -1.25728, -1.56661, -1.89185, -2.2048, -2.52664, -2.82857, -3.1296, -3.44648, -3.75461, -4.07825, -4.38763, -4.69784, -5.02162, -5.33394, -5.66077, -5.97397, -6.28488, -6.60655, -6.91518, -7.23732, -7.54787, -7.85409, -8.1677, -8.46776, -8.78181, -9.09287, -9.40915, -9.73494, -10.04675, -10.37159, -10.68583, -10.99763, -11.31616, -11.62331, -11.94581, -12.25587, -12.56495, -12.88368, -13.19046, -13.51269, -13.82549, -14.13627, -14.45465, -14.76211, -15.08471, -15.39473, -15.70189, -16.01663, -16.3231, -16.64843, -16.96478, -17.2793, -17.59721, -17.90403, -18.2284, -18.54094, -18.84873, -19.16223, -19.46673, -19.78921, -20.10066, -20.41349, -20.73869, -21.05149, -21.37599, -21.68448, -21.99119, -22.30769, -22.6141, -22.93768, -23.24797, -23.55666, -23.8779, -24.18644, -24.50759, -24.8179, -25.12781, -25.44738, -25.75514, -26.07829])
        expected.curve_filter.y = np.array([-1])
        expected.curve_IQ.y = np.array([1344.5, 1484.4375, 1485.8125, 1342.5625, 1054.6875, 680.0, 218.5, -241.0, -698.5, -1064.4375, -1338.8125, -1474.875, -1472.625, -1336.0, -1065.0, -699.375, -239.125, 227.0625, 699.1875, 1076.3125, 1358.4375, 1493.0, 1480.0, 1331.0625, 1046.1875, 680.125, 232.875, -215.125, -663.875, -1031.75, -1318.75, -1464.6875, -1469.5625, -1331.0, -1049.0, -679.8125, -223.4375, 235.75, 697.75, 1070.375, 1353.625, 1492.1875, 1486.0625, 1339.875, 1053.625, 682.875, 227.625, -231.8125, -695.4375, -1068.6875, -1351.5625, -1488.5, -1479.5, -1334.375, -1053.125, -684.1875, -227.5625, 232.3125, 695.4375, 1066.8125, 1346.4375, 1484.9375, 1482.3125, 1341.0, 1061.0, 689.0, 225.0, -239.1875, -703.5625, -1079.3125, -1366.4375, -1507.25, -1501.75, -1355.75, -1069.25, -694.125, -230.375, 230.625, 688.875, 1058.4375, 1339.3125, 1478.0625, 1474.6875, 1330.875])
        expected.parent.raw_adc_samples = np.array([3335.0, 1026.0, -2619.0, -2578.0, 1074.0, 3245.0, 1044.0, -2656.0, -2654.0, 1026.0, 3282.0, 1060.0, -2626.0, -2647.0, 1027.0, 3288.0, 1062.0, -2658.0, -2641.0, 985.0, 3193.0, 1034.0, -2623.0, -2675.0, 1087.0, 3229.0, 1014.0, -2657.0, -2601.0, 1061.0, 3282.0, 1025.0, -2680.0, -2716.0, 1001.0, 3282.0, 1053.0, -2612.0, -2664.0, 1003.0, 3242.0, 966.0, -2707.0, -2587.0, 996.0, 3262.0, 972.0, -2626.0, -2704.0, 1006.0, 3247.0, 1025.0, -2668.0, -2690.0, 1012.0, 3291.0, 1015.0, -2641.0, -2672.0, 1001.0, 3255.0, 1001.0, -2678.0, -2708.0, 1018.0, 3264.0, 959.0, -2636.0, -2681.0, 1014.0, 3301.0, 1017.0, -2614.0, -2691.0, 1026.0, 3254.0, 984.0, -2670.0, -2661.0, 1014.0, 3239.0, 1042.0, -2636.0, -2701.0, 1061.0, 3339.0, 1051.0, -2657.0, -2686.0, 1047.0, 3264.0, 1053.0, -2644.0, -2619.0, 1024.0, 3300.0, 1013.0, -2592.0, -2647.0, 1026.0])


    elif test_number == 3:

        expected_outputs_as_text = """g.filtered_baseband_snr = 4.090108
g.qadc0_scale.value = 11.705200
g.qthermo_baseband_snr.value = 42.980217
g.qthermo_baseband_snr.value = 42.980217
g.qlabel_adc_fill_value.text() = 11.7 bits
g.qlabel_rawdata_rbw.text() = RBW: 1.5 MHz; Points:
g.qlabel_baseband_snr_value.text() = 4.09 dB
g.qplt_IQ.xmin_val = -2253.596044
g.qplt_IQ.xmax_val = 2253.596044
g.qplt_IQ.ymin_val = -2253.596044
g.qplt_IQ.ymax_val = 2253.596044
g.qplt_IQ.bReplotCalls = 0
g.plt_spc.xmin_val = 0.000000
g.plt_spc.xmax_val = 0.000001
g.plt_spc.ymin_val = -2253.59604401
g.plt_spc.ymax_val = 2253.596044
g.plt_spc.bReplotCalls = 0
g.plt_spc.strTitle = Time-domain IQ signals (I: blue, Q: red)
g.curve_spc.bVisible = -1
g.curve_filter.bVisible = 1
g.curve_IQ.bVisible = -1
g.parent.sl.bDDR2InUse = False"""

        expected.curve_spc.x = np.array([0.0, 8e-09, 1.6e-08, 2.4e-08, 3.2e-08, 4e-08, 4.8e-08, 5.6e-08, 6.4e-08, 7.2e-08, 8e-08, 8.8e-08, 9.6e-08, 1.04e-07, 1.12e-07, 1.2e-07, 1.28e-07, 1.36e-07, 1.44e-07, 1.52e-07, 1.6e-07, 1.68e-07, 1.76e-07, 1.84e-07, 1.92e-07, 2e-07, 2.08e-07, 2.16e-07, 2.24e-07, 2.32e-07, 2.4e-07, 2.48e-07, 2.56e-07, 2.64e-07, 2.72e-07, 2.8e-07, 2.88e-07, 2.96e-07, 3.04e-07, 3.12e-07, 3.2e-07, 3.28e-07, 3.36e-07, 3.44e-07, 3.52e-07, 3.6e-07, 3.68e-07, 3.76e-07, 3.84e-07, 3.92e-07, 4e-07, 4.08e-07, 4.16e-07, 4.24e-07, 4.32e-07, 4.4e-07, 4.48e-07, 4.56e-07, 4.64e-07, 4.72e-07, 4.8e-07, 4.88e-07, 4.96e-07, 5.04e-07, 5.12e-07, 5.2e-07, 5.28e-07, 5.36e-07, 5.44e-07, 5.52e-07, 5.6e-07, 5.68e-07, 5.76e-07, 5.84e-07, 5.92e-07, 6e-07, 6.08e-07, 6.16e-07, 6.24e-07, 6.32e-07, 6.4e-07, 6.48e-07, 6.56e-07, 6.64e-07])
        expected.curve_filter.x = np.array([0.0, 8e-09, 1.6e-08, 2.4e-08, 3.2e-08, 4e-08, 4.8e-08, 5.6e-08, 6.4e-08, 7.2e-08, 8e-08, 8.8e-08, 9.6e-08, 1.04e-07, 1.12e-07, 1.2e-07, 1.28e-07, 1.36e-07, 1.44e-07, 1.52e-07, 1.6e-07, 1.68e-07, 1.76e-07, 1.84e-07, 1.92e-07, 2e-07, 2.08e-07, 2.16e-07, 2.24e-07, 2.32e-07, 2.4e-07, 2.48e-07, 2.56e-07, 2.64e-07, 2.72e-07, 2.8e-07, 2.88e-07, 2.96e-07, 3.04e-07, 3.12e-07, 3.2e-07, 3.28e-07, 3.36e-07, 3.44e-07, 3.52e-07, 3.6e-07, 3.68e-07, 3.76e-07, 3.84e-07, 3.92e-07, 4e-07, 4.08e-07, 4.16e-07, 4.24e-07, 4.32e-07, 4.4e-07, 4.48e-07, 4.56e-07, 4.64e-07, 4.72e-07, 4.8e-07, 4.88e-07, 4.96e-07, 5.04e-07, 5.12e-07, 5.2e-07, 5.28e-07, 5.36e-07, 5.44e-07, 5.52e-07, 5.6e-07, 5.68e-07, 5.76e-07, 5.84e-07, 5.92e-07, 6e-07, 6.08e-07, 6.16e-07, 6.24e-07, 6.32e-07, 6.4e-07, 6.48e-07, 6.56e-07, 6.64e-07])
        expected.curve_IQ.x = np.array([-682.75, -221.75, 238.0, 696.5, 1058.9375, 1325.3125, 1457.375, 1455.125, 1322.375, 1059.125, 700.1875, 245.5625, -212.25, -673.25, -1045.5, -1329.0, -1475.6875, -1485.5625, -1347.9375, -1062.8125, -686.9375, -220.3125, 242.0625, 700.1875, 1066.0625, 1339.6875, 1479.1875, 1484.5625, 1346.875, 1066.125, 695.8125, 235.9375, -225.25, -687.75, -1061.1875, -1345.5625, -1485.5, -1481.0, -1339.0625, -1059.6875, -689.8125, -229.4375, 231.0, 691.5, 1061.75, 1341.75, 1482.125, 1482.875, 1343.4375, 1063.8125, 696.6875, 242.0625, -216.4375, -678.8125, -1056.375, -1349.125, -1491.3125, -1482.9375, -1336.5625, -1052.1875, -685.125, -235.375, 219.9375, 680.8125, 1052.1875, 1334.0625, 1473.4375, 1470.3125, 1332.625, 1060.375, 693.8125, 232.9375, -231.6875, -700.0625, -1072.5625, -1349.1875, -1484.875, -1479.625, -1337.0, -1057.0, -688.4375, -231.3125, 226.6875, 685.5625])
        expected.curve_spc.y = np.array([-682.75, -221.75, 238.0, 696.5, 1058.9375, 1325.3125, 1457.375, 1455.125, 1322.375, 1059.125, 700.1875, 245.5625, -212.25, -673.25, -1045.5, -1329.0, -1475.6875, -1485.5625, -1347.9375, -1062.8125, -686.9375, -220.3125, 242.0625, 700.1875, 1066.0625, 1339.6875, 1479.1875, 1484.5625, 1346.875, 1066.125, 695.8125, 235.9375, -225.25, -687.75, -1061.1875, -1345.5625, -1485.5, -1481.0, -1339.0625, -1059.6875, -689.8125, -229.4375, 231.0, 691.5, 1061.75, 1341.75, 1482.125, 1482.875, 1343.4375, 1063.8125, 696.6875, 242.0625, -216.4375, -678.8125, -1056.375, -1349.125, -1491.3125, -1482.9375, -1336.5625, -1052.1875, -685.125, -235.375, 219.9375, 680.8125, 1052.1875, 1334.0625, 1473.4375, 1470.3125, 1332.625, 1060.375, 693.8125, 232.9375, -231.6875, -700.0625, -1072.5625, -1349.1875, -1484.875, -1479.625, -1337.0, -1057.0, -688.4375, -231.3125, 226.6875, 685.5625])
        expected.curve_filter.y = np.array([1344.5, 1484.4375, 1485.8125, 1342.5625, 1054.6875, 680.0, 218.5, -241.0, -698.5, -1064.4375, -1338.8125, -1474.875, -1472.625, -1336.0, -1065.0, -699.375, -239.125, 227.0625, 699.1875, 1076.3125, 1358.4375, 1493.0, 1480.0, 1331.0625, 1046.1875, 680.125, 232.875, -215.125, -663.875, -1031.75, -1318.75, -1464.6875, -1469.5625, -1331.0, -1049.0, -679.8125, -223.4375, 235.75, 697.75, 1070.375, 1353.625, 1492.1875, 1486.0625, 1339.875, 1053.625, 682.875, 227.625, -231.8125, -695.4375, -1068.6875, -1351.5625, -1488.5, -1479.5, -1334.375, -1053.125, -684.1875, -227.5625, 232.3125, 695.4375, 1066.8125, 1346.4375, 1484.9375, 1482.3125, 1341.0, 1061.0, 689.0, 225.0, -239.1875, -703.5625, -1079.3125, -1366.4375, -1507.25, -1501.75, -1355.75, -1069.25, -694.125, -230.375, 230.625, 688.875, 1058.4375, 1339.3125, 1478.0625, 1474.6875, 1330.875])
        expected.curve_IQ.y = np.array([1344.5, 1484.4375, 1485.8125, 1342.5625, 1054.6875, 680.0, 218.5, -241.0, -698.5, -1064.4375, -1338.8125, -1474.875, -1472.625, -1336.0, -1065.0, -699.375, -239.125, 227.0625, 699.1875, 1076.3125, 1358.4375, 1493.0, 1480.0, 1331.0625, 1046.1875, 680.125, 232.875, -215.125, -663.875, -1031.75, -1318.75, -1464.6875, -1469.5625, -1331.0, -1049.0, -679.8125, -223.4375, 235.75, 697.75, 1070.375, 1353.625, 1492.1875, 1486.0625, 1339.875, 1053.625, 682.875, 227.625, -231.8125, -695.4375, -1068.6875, -1351.5625, -1488.5, -1479.5, -1334.375, -1053.125, -684.1875, -227.5625, 232.3125, 695.4375, 1066.8125, 1346.4375, 1484.9375, 1482.3125, 1341.0, 1061.0, 689.0, 225.0, -239.1875, -703.5625, -1079.3125, -1366.4375, -1507.25, -1501.75, -1355.75, -1069.25, -694.125, -230.375, 230.625, 688.875, 1058.4375, 1339.3125, 1478.0625, 1474.6875, 1330.875])
        expected.parent.raw_adc_samples = np.array([3335.0, 1026.0, -2619.0, -2578.0, 1074.0, 3245.0, 1044.0, -2656.0, -2654.0, 1026.0, 3282.0, 1060.0, -2626.0, -2647.0, 1027.0, 3288.0, 1062.0, -2658.0, -2641.0, 985.0, 3193.0, 1034.0, -2623.0, -2675.0, 1087.0, 3229.0, 1014.0, -2657.0, -2601.0, 1061.0, 3282.0, 1025.0, -2680.0, -2716.0, 1001.0, 3282.0, 1053.0, -2612.0, -2664.0, 1003.0, 3242.0, 966.0, -2707.0, -2587.0, 996.0, 3262.0, 972.0, -2626.0, -2704.0, 1006.0, 3247.0, 1025.0, -2668.0, -2690.0, 1012.0, 3291.0, 1015.0, -2641.0, -2672.0, 1001.0, 3255.0, 1001.0, -2678.0, -2708.0, 1018.0, 3264.0, 959.0, -2636.0, -2681.0, 1014.0, 3301.0, 1017.0, -2614.0, -2691.0, 1026.0, 3254.0, 984.0, -2670.0, -2661.0, 1014.0, 3239.0, 1042.0, -2636.0, -2701.0, 1061.0, 3339.0, 1051.0, -2657.0, -2686.0, 1047.0, 3264.0, 1053.0, -2644.0, -2619.0, 1024.0, 3300.0, 1013.0, -2592.0, -2647.0, 1026.0])


    elif test_number == 4:

        expected_outputs_as_text = """g.filtered_baseband_snr = 4.090108
g.qadc0_scale.value = 11.705200
g.qthermo_baseband_snr.value = 42.980217
g.qthermo_baseband_snr.value = 42.980217
g.qlabel_adc_fill_value.text() = 11.7 bits
g.qlabel_rawdata_rbw.text() = RBW: 1.5 MHz; Points:
g.qlabel_baseband_snr_value.text() = 4.09 dB
g.qplt_IQ.xmin_val = -2253.596044
g.qplt_IQ.xmax_val = 2253.596044
g.qplt_IQ.ymin_val = -2253.596044
g.qplt_IQ.ymax_val = 2253.596044
g.qplt_IQ.bReplotCalls = 0
g.plt_spc.xmin_val = 0.000000
g.plt_spc.xmax_val = 0.000001
g.plt_spc.ymin_val = -2253.596044
g.plt_spc.ymax_val = 2253.596044
g.plt_spc.bReplotCalls = 0
g.plt_spc.strTitle = Time-domain IQ signals, phase aligned at t=0
g.curve_spc.bVisible = -1
g.curve_filter.bVisible = 1
g.curve_IQ.bVisible = -1
g.parent.sl.bDDR2InUse = False"""


        expected.curve_spc.x = np.array([0.0, 8e-09, 1.6e-08, 2.4e-08, 3.2e-08, 4e-08, 4.8e-08, 5.6e-08, 6.4e-08, 7.2e-08, 8e-08, 8.8e-08, 9.6e-08, 1.04e-07, 1.12e-07, 1.2e-07, 1.28e-07, 1.36e-07, 1.44e-07, 1.52e-07, 1.6e-07, 1.68e-07, 1.76e-07, 1.84e-07, 1.92e-07, 2e-07, 2.08e-07, 2.16e-07, 2.24e-07, 2.32e-07, 2.4e-07, 2.48e-07, 2.56e-07, 2.64e-07, 2.72e-07, 2.8e-07, 2.88e-07, 2.96e-07, 3.04e-07, 3.12e-07, 3.2e-07, 3.28e-07, 3.36e-07, 3.44e-07, 3.52e-07, 3.6e-07, 3.68e-07, 3.76e-07, 3.84e-07, 3.92e-07, 4e-07, 4.08e-07, 4.16e-07, 4.24e-07, 4.32e-07, 4.4e-07, 4.48e-07, 4.56e-07, 4.64e-07, 4.72e-07, 4.8e-07, 4.88e-07, 4.96e-07, 5.04e-07, 5.12e-07, 5.2e-07, 5.28e-07, 5.36e-07, 5.44e-07, 5.52e-07, 5.6e-07, 5.68e-07, 5.76e-07, 5.84e-07, 5.92e-07, 6e-07, 6.08e-07, 6.16e-07, 6.24e-07, 6.32e-07, 6.4e-07, 6.48e-07, 6.56e-07, 6.64e-07])
        expected.curve_filter.x = np.array([0.0, 8e-09, 1.6e-08, 2.4e-08, 3.2e-08, 4e-08, 4.8e-08, 5.6e-08, 6.4e-08, 7.2e-08, 8e-08, 8.8e-08, 9.6e-08, 1.04e-07, 1.12e-07, 1.2e-07, 1.28e-07, 1.36e-07, 1.44e-07, 1.52e-07, 1.6e-07, 1.68e-07, 1.76e-07, 1.84e-07, 1.92e-07, 2e-07, 2.08e-07, 2.16e-07, 2.24e-07, 2.32e-07, 2.4e-07, 2.48e-07, 2.56e-07, 2.64e-07, 2.72e-07, 2.8e-07, 2.88e-07, 2.96e-07, 3.04e-07, 3.12e-07, 3.2e-07, 3.28e-07, 3.36e-07, 3.44e-07, 3.52e-07, 3.6e-07, 3.68e-07, 3.76e-07, 3.84e-07, 3.92e-07, 4e-07, 4.08e-07, 4.16e-07, 4.24e-07, 4.32e-07, 4.4e-07, 4.48e-07, 4.56e-07, 4.64e-07, 4.72e-07, 4.8e-07, 4.88e-07, 4.96e-07, 5.04e-07, 5.12e-07, 5.2e-07, 5.28e-07, 5.36e-07, 5.44e-07, 5.52e-07, 5.6e-07, 5.68e-07, 5.76e-07, 5.84e-07, 5.92e-07, 6e-07, 6.08e-07, 6.16e-07, 6.24e-07, 6.32e-07, 6.4e-07, 6.48e-07, 6.56e-07, 6.64e-07])
        expected.curve_IQ.x = np.array([-682.75, -221.75, 238.0, 696.5, 1058.9375, 1325.3125, 1457.375, 1455.125, 1322.375, 1059.125, 700.1875, 245.5625, -212.25, -673.25, -1045.5, -1329.0, -1475.6875, -1485.5625, -1347.9375, -1062.8125, -686.9375, -220.3125, 242.0625, 700.1875, 1066.0625, 1339.6875, 1479.1875, 1484.5625, 1346.875, 1066.125, 695.8125, 235.9375, -225.25, -687.75, -1061.1875, -1345.5625, -1485.5, -1481.0, -1339.0625, -1059.6875, -689.8125, -229.4375, 231.0, 691.5, 1061.75, 1341.75, 1482.125, 1482.875, 1343.4375, 1063.8125, 696.6875, 242.0625, -216.4375, -678.8125, -1056.375, -1349.125, -1491.3125, -1482.9375, -1336.5625, -1052.1875, -685.125, -235.375, 219.9375, 680.8125, 1052.1875, 1334.0625, 1473.4375, 1470.3125, 1332.625, 1060.375, 693.8125, 232.9375, -231.6875, -700.0625, -1072.5625, -1349.1875, -1484.875, -1479.625, -1337.0, -1057.0, -688.4375, -231.3125, 226.6875, 685.5625])
        expected.curve_spc.y = np.array([1507.921686461, 1423.963890518, 1217.026336797, 881.703551442, 460.92431183, 6.235662442, -465.043733734, -873.726471062, -1221.538756149, -1428.624464945, -1510.745844647, -1426.219447392, -1216.927007202, -886.379295756, -476.203360856, -21.841278493, 454.945428721, 875.080808223, 1233.725821824, 1440.882116182, 1522.24470109, 1430.94756097, 1210.0043686, 869.780259413, 450.119477669, -0.161532344, -462.102796439, -863.984264616, -1201.759255816, -1402.648915882, -1490.876734223, -1412.77805804, -1208.310325469, -875.355928197, -454.834452301, 3.100221097, 473.375648523, 880.761008297, 1228.42572894, 1434.17317195, 1519.255487499, 1434.354692485, 1220.418671456, 881.57118797, 458.70352964, 1.356585702, -468.113853384, -878.099190686, -1228.344739986, -1434.536254467, -1520.529343441, -1436.783117669, -1221.160928587, -882.411842121, -460.691385691, 0.812376406, 472.329454852, 878.573301432, 1225.231908403, 1427.600943207, 1510.724550853, 1430.578769023, 1222.083908382, 887.413303781, 469.608926467, 10.29849777, -466.520880654, -878.986929511, -1230.693554355, -1442.453349553, -1532.490529099, -1449.369501578, -1234.094748476, -891.848837509, -467.739528158, -8.019844123, 466.907018495, 875.568866145, 1219.578711555, 1422.312569682, 1505.871544764, 1422.609449738, 1212.229036519, 876.23492154])
        expected.curve_filter.y = np.array([0.0, -474.399190984, -884.946145649, -1228.895912508, -1421.711338608, -1489.568507713, -1398.362780662, -1188.30628181, -862.798329768, -462.390630518, -18.12286382, 448.837715564, 856.015836458, 1205.194302408, 1414.399381048, 1501.628898623, 1424.029150041, 1221.755662722, 885.279199252, 460.301786961, -2.576880756, -479.557791524, -885.936612786, -1226.976859765, -1424.215571775, -1502.442207604, -1424.319989084, -1226.269045735, -900.320483112, -483.432101644, -23.305814928, 452.806951452, 866.220330673, 1215.858980915, 1421.14233318, 1507.539009509, 1425.675300267, 1213.754138516, 878.016896127, 460.203814781, 2.165521943, -471.053837379, -878.817967653, -1223.220955578, -1423.737958692, -1505.526315878, -1424.562064819, -1217.208738096, -882.964796898, -464.645824724, -9.229290221, 458.127467728, 862.862345858, 1209.418203793, 1418.719088967, 1512.696314805, 1432.725566933, 1217.038076879, 876.834878095, 455.129643361, 1.240355777, -462.477194198, -867.256462896, -1214.201090606, -1418.551018236, -1501.44520208, -1415.627540817, -1202.668485312, -869.645305455, -456.770125603, 0.069165976, 474.753082456, 886.533875235, 1238.043301925, 1440.453266408, 1517.251497901, 1428.259164973, 1214.848629208, 880.196303075, 463.21258136, 7.419887568, -462.986587363, -869.822515421, -1213.851955267])
        expected.curve_IQ.y = np.array([1344.5, 1484.4375, 1485.8125, 1342.5625, 1054.6875, 680.0, 218.5, -241.0, -698.5, -1064.4375, -1338.8125, -1474.875, -1472.625, -1336.0, -1065.0, -699.375, -239.125, 227.0625, 699.1875, 1076.3125, 1358.4375, 1493.0, 1480.0, 1331.0625, 1046.1875, 680.125, 232.875, -215.125, -663.875, -1031.75, -1318.75, -1464.6875, -1469.5625, -1331.0, -1049.0, -679.8125, -223.4375, 235.75, 697.75, 1070.375, 1353.625, 1492.1875, 1486.0625, 1339.875, 1053.625, 682.875, 227.625, -231.8125, -695.4375, -1068.6875, -1351.5625, -1488.5, -1479.5, -1334.375, -1053.125, -684.1875, -227.5625, 232.3125, 695.4375, 1066.8125, 1346.4375, 1484.9375, 1482.3125, 1341.0, 1061.0, 689.0, 225.0, -239.1875, -703.5625, -1079.3125, -1366.4375, -1507.25, -1501.75, -1355.75, -1069.25, -694.125, -230.375, 230.625, 688.875, 1058.4375, 1339.3125, 1478.0625, 1474.6875, 1330.875])
        expected.parent.raw_adc_samples = np.array([3335.0, 1026.0, -2619.0, -2578.0, 1074.0, 3245.0, 1044.0, -2656.0, -2654.0, 1026.0, 3282.0, 1060.0, -2626.0, -2647.0, 1027.0, 3288.0, 1062.0, -2658.0, -2641.0, 985.0, 3193.0, 1034.0, -2623.0, -2675.0, 1087.0, 3229.0, 1014.0, -2657.0, -2601.0, 1061.0, 3282.0, 1025.0, -2680.0, -2716.0, 1001.0, 3282.0, 1053.0, -2612.0, -2664.0, 1003.0, 3242.0, 966.0, -2707.0, -2587.0, 996.0, 3262.0, 972.0, -2626.0, -2704.0, 1006.0, 3247.0, 1025.0, -2668.0, -2690.0, 1012.0, 3291.0, 1015.0, -2641.0, -2672.0, 1001.0, 3255.0, 1001.0, -2678.0, -2708.0, 1018.0, 3264.0, 959.0, -2636.0, -2681.0, 1014.0, 3301.0, 1017.0, -2614.0, -2691.0, 1026.0, 3254.0, 984.0, -2670.0, -2661.0, 1014.0, 3239.0, 1042.0, -2636.0, -2701.0, 1061.0, 3339.0, 1051.0, -2657.0, -2686.0, 1047.0, 3264.0, 1053.0, -2644.0, -2619.0, 1024.0, 3300.0, 1013.0, -2592.0, -2647.0, 1026.0])


    else:
        expected_outputs_as_text = """g.filtered_baseband_snr = 4.090108
g.qadc0_scale.value = 11.705200
g.qthermo_baseband_snr.value = 42.980217
g.qthermo_baseband_snr.value = 42.980217
g.qlabel_adc_fill_value.text() = 11.7 bits
g.qlabel_rawdata_rbw.text() = RBW: 2.2 MHz; Points:
g.qlabel_baseband_snr_value.text() = 4.09 dB
g.qplt_IQ.xmin_val = -0.068774
g.qplt_IQ.xmax_val = 0.068774
g.qplt_IQ.ymin_val = -0.068774
g.qplt_IQ.ymax_val = 0.068774
g.qplt_IQ.bReplotCalls = 0
g.plt_spc.xmin_val = 0.000000
g.plt_spc.xmax_val = 0.000001
g.plt_spc.ymin_val = -0.092140
g.plt_spc.ymax_val = 0.111153
g.plt_spc.bReplotCalls = 0
g.plt_spc.strTitle = Time, std = 70.74 mV, ampl = 200.09 mVpp
g.curve_spc.bVisible = -1
g.curve_filter.bVisible = 0
g.curve_IQ.bVisible = -1
g.parent.sl.bDDR2InUse = False"""

        expected.curve_spc.x = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        expected.curve_filter.x = np.array([])
        expected.curve_IQ.x = np.array([-0.02084, -0.00677, 0.00726, 0.02126, 0.03232, 0.04045, 0.04448, 0.04441, 0.04036, 0.03232, 0.02137, 0.00749, -0.00648, -0.02055, -0.03191, -0.04056, -0.04503, -0.04534, -0.04114, -0.03243, -0.02096, -0.00672, 0.00739, 0.02137, 0.03253, 0.04088, 0.04514, 0.04531, 0.0411, 0.03254, 0.02123, 0.0072, -0.00687, -0.02099, -0.03238, -0.04106, -0.04533, -0.0452, -0.04086, -0.03234, -0.02105, -0.007, 0.00705, 0.0211, 0.0324, 0.04095, 0.04523, 0.04525, 0.041, 0.03246, 0.02126, 0.00739, -0.00661, -0.02072, -0.03224, -0.04117, -0.04551, -0.04526, -0.04079, -0.03211, -0.02091, -0.00718, 0.00671, 0.02078, 0.03211, 0.04071, 0.04497, 0.04487, 0.04067, 0.03236, 0.02117, 0.00711, -0.00707, -0.02136, -0.03273, -0.04117, -0.04531, -0.04515, -0.0408, -0.03226, -0.02101, -0.00706, 0.00692, 0.02092])
        expected.curve_spc.y = np.array([0.10178, 0.03131, -0.07993, -0.07867, 0.03278, 0.09903, 0.03186, -0.08105, -0.08099, 0.03131, 0.10016, 0.03235, -0.08014, -0.08078, 0.03134, 0.10034, 0.03241, -0.08112, -0.0806, 0.03006, 0.09744, 0.03156, -0.08005, -0.08163, 0.03317, 0.09854, 0.03094, -0.08109, -0.07938, 0.03238, 0.10016, 0.03128, -0.08179, -0.08289, 0.03055, 0.10016, 0.03214, -0.07971, -0.0813, 0.03061, 0.09894, 0.02948, -0.08261, -0.07895, 0.0304, 0.09955, 0.02966, -0.08014, -0.08252, 0.0307, 0.09909, 0.03128, -0.08142, -0.08209, 0.03088, 0.10043, 0.03098, -0.0806, -0.08154, 0.03055, 0.09933, 0.03055, -0.08173, -0.08264, 0.03107, 0.09961, 0.02927, -0.08044, -0.08182, 0.03094, 0.10074, 0.03104, -0.07977, -0.08212, 0.03131, 0.0993, 0.03003, -0.08148, -0.08121, 0.03094, 0.09885, 0.0318, -0.08044, -0.08243, 0.03238, 0.1019, 0.03207, -0.08109, -0.08197, 0.03195, 0.09961, 0.03214, -0.08069, -0.07993, 0.03125, 0.10071, 0.03091, -0.0791, -0.08078, 0.03131])
        expected.curve_filter.y = np.array([])
        expected.curve_IQ.y = np.array([0.04103, 0.0453, 0.04534, 0.04097, 0.03219, 0.02075, 0.00667, -0.00735, -0.02132, -0.03248, -0.04086, -0.04501, -0.04494, -0.04077, -0.0325, -0.02134, -0.0073, 0.00693, 0.02134, 0.03285, 0.04146, 0.04556, 0.04517, 0.04062, 0.03193, 0.02076, 0.00711, -0.00657, -0.02026, -0.03149, -0.04025, -0.0447, -0.04485, -0.04062, -0.03201, -0.02075, -0.00682, 0.00719, 0.02129, 0.03267, 0.04131, 0.04554, 0.04535, 0.04089, 0.03215, 0.02084, 0.00695, -0.00707, -0.02122, -0.03261, -0.04125, -0.04543, -0.04515, -0.04072, -0.03214, -0.02088, -0.00694, 0.00709, 0.02122, 0.03256, 0.04109, 0.04532, 0.04524, 0.04092, 0.03238, 0.02103, 0.00687, -0.0073, -0.02147, -0.03294, -0.0417, -0.046, -0.04583, -0.04137, -0.03263, -0.02118, -0.00703, 0.00704, 0.02102, 0.0323, 0.04087, 0.04511, 0.045, 0.04062])
        expected.parent.raw_adc_samples = np.array([3335.0, 1026.0, -2619.0, -2578.0, 1074.0, 3245.0, 1044.0, -2656.0, -2654.0, 1026.0, 3282.0, 1060.0, -2626.0, -2647.0, 1027.0, 3288.0, 1062.0, -2658.0, -2641.0, 985.0, 3193.0, 1034.0, -2623.0, -2675.0, 1087.0, 3229.0, 1014.0, -2657.0, -2601.0, 1061.0, 3282.0, 1025.0, -2680.0, -2716.0, 1001.0, 3282.0, 1053.0, -2612.0, -2664.0, 1003.0, 3242.0, 966.0, -2707.0, -2587.0, 996.0, 3262.0, 972.0, -2626.0, -2704.0, 1006.0, 3247.0, 1025.0, -2668.0, -2690.0, 1012.0, 3291.0, 1015.0, -2641.0, -2672.0, 1001.0, 3255.0, 1001.0, -2678.0, -2708.0, 1018.0, 3264.0, 959.0, -2636.0, -2681.0, 1014.0, 3301.0, 1017.0, -2614.0, -2691.0, 1026.0, 3254.0, 984.0, -2670.0, -2661.0, 1014.0, 3239.0, 1042.0, -2636.0, -2701.0, 1061.0, 3339.0, 1051.0, -2657.0, -2686.0, 1047.0, 3264.0, 1053.0, -2644.0, -2619.0, 1024.0, 3300.0, 1013.0, -2592.0, -2647.0, 1026.0])

    return check_fields(g, test_number, expected, expected_outputs_as_text)

def check_fields(g, test_number, expected, expected_outputs_as_text):

    (bPass, strFailedFields)       = compare_struct_fields(g, expected)
    (bPassNew, strFailedFieldsNew) = compare_text_fields(g, expected_outputs_as_text)
    # Combine the results of both types of comparisons:
    bPass = bPass and bPassNew
    strFailedFields += strFailedFieldsNew

    if bPass:
        print("Test #%d PASSED" % test_number)
    else:
        print("Test #%d FAILED: %s" % (test_number, strFailedFields))

    return bPass





# this is not called directly by pytest, but is called by our function which sets up the fixtures.
# Note that we do not use pytest's fixtures feature directly.
def inner_test_grabAndDisplayADC(sl, gui_mainwindow, test_number, bPrintAllOutputState=False):
    # shorthand:
    # g = gui_mainwindow
    g = gui_mainwindow.spectrum # almost all the displayADC functions has been re-factored into its ouw Widget

    # set GUI-based inputs:
    g.qedit_rawdata_length.setText("100") # only use 100 pts so that the outputs are easier to check
    g.bDisplayTiming = False
    if test_number == 0:
        # Possible values: 'Spectrum', 'Time: raw input', 'Time: Phase', 'Time: IQ', 'Time: IQ, synced'
        g.qcombo_adc_plottype.setCurrentIndex(g.qcombo_adc_plottype.findText('Spectrum'))
    elif test_number == 1:
        # Possible values: 'Spectrum', 'Time: raw input', 'Time: Phase', 'Time: IQ', 'Time: IQ, synced'
        g.qcombo_adc_plottype.setCurrentIndex(g.qcombo_adc_plottype.findText('Time: raw input'))
    elif test_number == 2:
        # Possible values: 'Spectrum', 'Time: raw input', 'Time: Phase', 'Time: IQ', 'Time: IQ, synced'
        g.qcombo_adc_plottype.setCurrentIndex(g.qcombo_adc_plottype.findText('Time: Phase'))
    elif test_number == 3:
        # Possible values: 'Spectrum', 'Time: raw input', 'Time: Phase', 'Time: IQ', 'Time: IQ, synced'
        g.qcombo_adc_plottype.setCurrentIndex(g.qcombo_adc_plottype.findText('Time: IQ'))
    elif test_number == 4:
        # Possible values: 'Spectrum', 'Time: raw input', 'Time: Phase', 'Time: IQ', 'Time: IQ, synced'
        g.qcombo_adc_plottype.setCurrentIndex(g.qcombo_adc_plottype.findText('Time: IQ, synced'))
    else:
        print("Error: unknown test number (%d)" % test_number)
        return


    # possible values: 'ADC 0', 'ADC 1', 'DAC 0', 'DAC 1', 'DAC 2'
    g.qcombo_adc_plot.setCurrentIndex(g.qcombo_adc_plot.findText('ADC0'))
    # possible values: 'Freq', 'Phase', 'Freq: time domain', 'Phase: time domain'
    # g.qcombo_ddc_plot.setCurrentIndex(g.qcombo_ddc_plot.findText('Phase'))


    # replace the PyQtGraph objects that are acted on with our interceptors so that we can verify the correct outputs without requiring knowledge of the internal structure of the objects in PyQtGraph:
    g.curve_spc    = PlotWindowIntercept(g.curve_spc)
    g.curve_filter = PlotWindowIntercept(g.curve_filter)
    g.curve_IQ     = PlotWindowIntercept(g.curve_IQ)
    g.qplt_IQ = PlotWidgetIntercept(g.qplt_IQ)
    g.plt_spc = PlotWidgetIntercept(g.plt_spc)

    gui_mainwindow.grabAndDisplayADC() # this is the only call that is still in the gui_mainwindow object instead of the SpectrumWidget object

    # this is used to determine what the "true" outputs should be
    if bPrintAllOutputState:
        print_all_state(g)

    # Check the outputs against the expected:
    if check_grabAndDisplayADC_outputs(g, test_number):
        return True
    else:
        assert 0
        return False

exception_locations = ['setup_write', 'read_adc_samples_from_DDR2', 'trigger_write', 'read_ddc_samples_from_DDR2']

def injectSLexception(sl, location, exception_locations):
    for location in exception_locations:
        # first clear all exceptions triggers:
        for location_clear in exception_locations:
            sl.bIntroduceCommsException[location_clear] = False
        # then add the one we actually want to test:
        sl.bIntroduceCommsException[location] = True

def inner_test_chkLockClickedEvent(sl, sp, selected_ADC, checked, bCheckValues, updateFilterSettingsException=False, updateSettingsException=False):

    if selected_ADC == 0:
        output_controls = (True, False, False)

    elif selected_ADC == 1:
        output_controls = (False, True, True)

    # Setup all and state:
    g = XEM_GUI_MainWindow(sl, 'Testing window', selected_ADC, output_controls, sp, '', '')
    # make sure that the VCO gain is equal to the detected VCO gain, to avoid creating MessageBoxes:
    g.VCO_detected_gain_in_Hz_per_Volts[g.selected_ADC] = g.getVCOGainFromUI(g.selected_ADC)
    g.bFirstTimeLockCheckBoxClicked = False
    g.sl.dither_mode_auto = (1, 1) # need to test with this on too, because of the call to sl.setDitherLockInState()
    g.sl.output_vco = [0, 0]
    g.qchk_lock.setChecked(checked)

    # setup mocks:
    setDitherLockInState = count_calls()
    updateFilterSettings = count_calls()
    updateSettings       = count_calls()
    if updateFilterSettingsException:
        updateFilterSettings.raise_exception = True
        updateFilterSettings.exception = RP_PLL.CommsError()
    if updateSettingsException:
        updateSettings.raise_exception = True
        updateSettings.exception = RP_PLL.CommsError()
    sl.setDitherLockInState = setDitherLockInState.calls_counting
    if selected_ADC == 0:
        g.qloop_filters[0].updateFilterSettings = updateFilterSettings.calls_counting
    elif selected_ADC == 1:
        g.qloop_filters[1].updateSettings = updateSettings.calls_counting
    

    # actual test call:
    g.chkLockClickedEvent()

    # bail out if we are just checking behavior during an exception:
    if bCheckValues == False:
        return

    # check outputs:
    if selected_ADC == 0:
        assert(setDitherLockInState.calls_number == 1);
        assert(updateFilterSettings.calls_number == 1);
        assert(g.qloop_filters[0].qchk_lock.isChecked() == checked)
    elif selected_ADC == 1:
        if checked:
            assert(g.qloop_filters[1].qradio_mode_off.isChecked() == False)
            assert(g.qloop_filters[1].qradio_mode_slow.isChecked() == False)
            assert(g.qloop_filters[1].qradio_mode_fast.isChecked() == False)
            assert(g.qloop_filters[1].qradio_mode_both.isChecked() == True)
            assert(setDitherLockInState.calls_number == 1);
            assert(updateSettings.calls_number == 2);
        else:
            assert(g.qloop_filters[1].qradio_mode_off.isChecked() == True)
            assert(g.qloop_filters[1].qradio_mode_slow.isChecked() == False)
            assert(g.qloop_filters[1].qradio_mode_fast.isChecked() == False)
            assert(g.qloop_filters[1].qradio_mode_both.isChecked() == False)
            assert(setDitherLockInState.calls_number == 1);
            assert(updateSettings.calls_number == 1);

def test_chkLockClickedEvent():


    # setup common stuff:
    (app, sp, sl) = initGuiObjects()

    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=0, checked=False, bCheckValues=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=0, checked=True, bCheckValues=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=1, checked=False, bCheckValues=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=1, checked=True, bCheckValues=True)


    # # TODO: need a test case with exceptions being thrown. There are a few places that can throw:
    # # these four fit in our previous pattern
    exception_locations = ['setDitherLockInState', 'read_adc_samples_from_DDR2', 'set_dac_offset', 'set_integrator_settings']


    for location in exception_locations:
        injectSLexception(sl, location, exception_locations)
        inner_test_chkLockClickedEvent(sl, sp, selected_ADC=0, checked=False, bCheckValues=False)
        inner_test_chkLockClickedEvent(sl, sp, selected_ADC=0, checked=True, bCheckValues=False)
        inner_test_chkLockClickedEvent(sl, sp, selected_ADC=1, checked=False, bCheckValues=False)
        inner_test_chkLockClickedEvent(sl, sp, selected_ADC=1, checked=True, bCheckValues=False)
        # nothing to check, we just verify that there is no unhandled exception

    # two other places that can throw but do not fit our easy injectSLexception() pattern:
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=0, checked=False, bCheckValues=False, updateFilterSettingsException=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=0, checked=True, bCheckValues=False, updateFilterSettingsException=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=1, checked=False, bCheckValues=False, updateFilterSettingsException=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=1, checked=True, bCheckValues=False, updateFilterSettingsException=True)

    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=0, checked=False, bCheckValues=False, updateSettingsException=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=0, checked=True, bCheckValues=False, updateSettingsException=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=1, checked=False, bCheckValues=False, updateSettingsException=True)
    inner_test_chkLockClickedEvent(sl, sp, selected_ADC=1, checked=True, bCheckValues=False, updateSettingsException=True)

# @pytest.mark.skip(reason="not fixed yet")
def test_timerEvent():
    (app, sp, sl) = initGuiObjects()
    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (True, False, False), sp, '', '')

    # shorthand:
    g = gui_mainwindow

    # setup correct state:
    g.qchk_phase_noise_fast_updates.setChecked(True)
    g.qchk_refresh.setChecked(True)

    # we can't have the timerEvent() function calling these since we didn't setup all the required mocks.
    # so we just count how many times the functions are called instead

    grabAndDisplayADC = count_calls()
    displayDAC = count_calls()
    displayDDC = count_calls()
    readLEDs = count_calls()

    g.grabAndDisplayADC = grabAndDisplayADC.calls_counting
    g.displayDAC = displayDAC.calls_counting
    g.displayDDC = displayDDC.calls_counting
    g.sl.readLEDs = readLEDs.calls_counting

    g.timerEvent(None)

    assert(grabAndDisplayADC.calls_number == 1)
    assert(displayDAC.calls_number == 1)
    assert(displayDDC.calls_number == 1)
    assert(readLEDs.calls_number == 1)

    # try calling it again, this time throwing an exception from sl.readLEDs()
    readLEDs.raise_exception = True
    readLEDs.exception = RP_PLL.CommsError()
    g.timerEvent(None)

    assert(grabAndDisplayADC.calls_number == 1)
    assert(displayDAC.calls_number == 1)
    assert(displayDDC.calls_number == 1)
    assert(readLEDs.calls_number == 2)


    # assert(0)

def inner_test_displayDDC(sl, gui_mainwindow, bCheckValues=True):
    # shorthand:
    g = gui_mainwindow

    g.qedit_ddc_length.setText('1000')
    g.qcombo_ddc_plot.setCurrentIndex(g.qcombo_ddc_plot.findText('Phase'))
    g.qplt_DDC0_spc = PlotWidgetIntercept(g.qplt_DDC0_spc)

    g.sl.random_seed = g.selected_ADC

    g.displayDDC()

    print("selected_ADC = %s" % str(gui_mainwindow.selected_ADC))
    if bCheckValues == False:
        print("skipped checking values.")
        return

    if g.selected_ADC == 0:
        assert(g.qlbl_mean_freq_error.text() == "Freq error: 0.10 MHz")
        assert(g.qplt_DDC0_spc.strTitle == "Phase noise PSD, std dev = 1.45 radrms")
    elif g.selected_ADC == 1:
        assert(g.qlbl_mean_freq_error.text() == "Freq error: 0.20 MHz")
        assert(g.qplt_DDC0_spc.strTitle == "Phase noise PSD, std dev = 2.90 radrms")
    else:
        assert(0) # invalid


def test_displayDDC():
    (app, sp, sl) = initGuiObjects()
    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (True, False, False), sp, '', '')
    inner_test_displayDDC(sl, gui_mainwindow)

    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 1, (False, True, True), sp, '', '')
    inner_test_displayDDC(sl, gui_mainwindow)

display_exception_locations = ['setup_write', 'read_adc_samples_from_DDR2', 'trigger_write', 'read_ddc_samples_from_DDR2']

# @pytest.mark.skip(reason="not fixed yet")
def test_displayDDC_withException():
    (app, sp, sl) = initGuiObjects()
    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (True, False, False), sp, '', '')

    for location in exception_locations:
        injectSLexception(sl, location, display_exception_locations)
        inner_test_displayDDC(sl, gui_mainwindow, bCheckValues=False) # no point in checking the outputs values, we just want to gracefully ignore the exception

        # check that the object state is still valid:
        assert(gui_mainwindow.sl.bDDR2InUse == False)

    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (False, True, True), sp, '', '')


    for location in exception_locations:
        injectSLexception(sl, location, display_exception_locations)
        inner_test_displayDDC(sl, gui_mainwindow, bCheckValues=False) # no point in checking the outputs values, we just want to gracefully ignore the exception

        # check that the object state is still valid:
        assert(gui_mainwindow.sl.bDDR2InUse == False)


def inner_test_displayDAC(sl, gui_mainwindow, bCheckValues=True):
    if gui_mainwindow.output_controls[0] == True:
        gui_mainwindow.sl.random_seed = 0
        expected_dacs = [326e-6+1e-4, 0, 0]
        expected_labels = ["0.0004 V\n0 MHz", "", ""]
    else:
        gui_mainwindow.sl.random_seed = 1
        expected_dacs = [0, 460e-6+2e-4, 1.254e-3]
        expected_labels = ["", "0.0007 V\n1 MHz", "0.0013 V\n1 MHz"]

    gui_mainwindow.displayDAC()

    print("output_controls = %s" % str(gui_mainwindow.output_controls))
    if bCheckValues == False:
        print("skipped checking values.")
        return

    for k in range(3):
        if gui_mainwindow.output_controls[k]:
            print("k = %d" % k)
            assert(close_enough(gui_mainwindow.spectrum.qthermo_dac_current[k].value, expected_dacs[k]))
            assert(str(gui_mainwindow.spectrum.qlabel_dac_current_value[k].text()) == expected_labels[k])

def test_displayDAC():
    (app, sp, sl) = initGuiObjects()
    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (True, False, False), sp, '', '')
    inner_test_displayDAC(sl, gui_mainwindow)

    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (False, True, True), sp, '', '')
    inner_test_displayDAC(sl, gui_mainwindow)

# @pytest.mark.skip(reason="not fixed yet")
def test_displayDAC_withException():
    (app, sp, sl) = initGuiObjects()
    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (True, False, False), sp, '', '')

    for location in exception_locations:
        injectSLexception(sl, location, display_exception_locations)
        inner_test_displayDAC(sl, gui_mainwindow, bCheckValues=False) # no point in checking the outputs values, we just want to gracefully ignore the exception

        # check that the object state is still valid:
        assert(gui_mainwindow.sl.bDDR2InUse == False)

    gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (False, True, True), sp, '', '')


    for location in exception_locations:
        injectSLexception(sl, location, display_exception_locations)
        inner_test_displayDAC(sl, gui_mainwindow, bCheckValues=False) # no point in checking the outputs values, we just want to gracefully ignore the exception

        # check that the object state is still valid:
        assert(gui_mainwindow.sl.bDDR2InUse == False)

# this is not called directly by pytest, but is called by our function which sets up the fixtures.
# Note that we do not use pytest's fixtures feature directly.
def inner_test_grabAndDisplayADC_withException(sl, gui_mainwindow):
    # shorthand:
    # g = gui_mainwindow
    g = gui_mainwindow.spectrum # almost all the displayADC functions has been re-factored into its ouw Widget

    # set GUI-based inputs:
    g.qedit_rawdata_length.setText("100") # only use 100 pts so that the outputs are easier to check
    g.bDisplayTiming = False
    # Possible values: 'Spectrum', 'Time: raw input', 'Time: Phase', 'Time: IQ', 'Time: IQ, synced'
    g.qcombo_adc_plottype.setCurrentIndex(g.qcombo_adc_plottype.findText('Spectrum'))


    # possible values: 'ADC 0', 'ADC 1', 'DAC 0', 'DAC 1', 'DAC 2'
    g.qcombo_adc_plot.setCurrentIndex(g.qcombo_adc_plot.findText('ADC0'))
    # possible values: 'Freq', 'Phase', 'Freq: time domain', 'Phase: time domain'
    # g.qcombo_ddc_plot.setCurrentIndex(g.qcombo_ddc_plot.findText('Phase'))


    # replace the PyQtGraph objects that are acted on with our interceptors so that we can verify the correct outputs without requiring knowledge of the internal structure of the objects in PyQtGraph:
    g.curve_spc    = PlotWindowIntercept(g.curve_spc)
    g.curve_filter = PlotWindowIntercept(g.curve_filter)
    g.curve_IQ     = PlotWindowIntercept(g.curve_IQ)
    g.qplt_IQ = PlotWidgetIntercept(g.qplt_IQ)
    g.plt_spc = PlotWidgetIntercept(g.plt_spc)


    for location in exception_locations:
        injectSLexception(sl, location, display_exception_locations)
        gui_mainwindow.grabAndDisplayADC() # this will throw (and hopefully handle gracefully) an Exception

        # check that the object state is still valid:
        assert(gui_mainwindow.sl.bDDR2InUse == False)




def start_qt():
    # Start Qt:
    app = QtCore.QCoreApplication.instance()
    if app is None:
        # print("QCoreApplication not running yet. creating.")
        bEventLoopWasRunningAlready = False
        app = QtWidgets.QApplication(sys.argv)
    else:
        bEventLoopWasRunningAlready = True
        # print("QCoreApplication already running.")

    return app

def initGuiObjects():
    app                = start_qt()
    sp                 = SLLSystemParameters()
    sl                 = SuperLaserLand_mock()
    sl.initSubModules() # this should definitely be moved to SuperLaserLand_JD_RP.__init__()
    return (app, sp, sl)

def test_grabAndDisplayADC_withException(bPrintAllOutputState=True):
    # This test adds a comms failure during the calls to grabAndDisplayADC and check that the GUI doesn't crash, and that it leaves everything in a correct state.
    (app, sp, sl) = initGuiObjects()
    xem_gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (True, False, False), sp, '', '')
    inner_test_grabAndDisplayADC_withException(sl, xem_gui_mainwindow)



def test_grabAndDisplayADC(bPrintAllOutputState=True):
    (app, sp, sl) = initGuiObjects()
    bPass = True
    for test_case in range(5):
        xem_gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (True, False, False), sp, '', '')
        bPass = bPass and inner_test_grabAndDisplayADC(sl, xem_gui_mainwindow, test_number=test_case, bPrintAllOutputState=bPrintAllOutputState)
        del xem_gui_mainwindow

    # xem_gui_mainwindow = XEM_GUI_MainWindow(sl, 'Testing window', 0, (True, False, False), sp, '', '')
    # bPass = bPass and test_grabAndDisplayADC(sl, xem_gui_mainwindow, test_number=2, bPrintAllOutputState=True)
    # xem_gui_mainwindow.show()

    if bPass:
        print("All tests PASSED")
    else:
        print("Some tests FAILED")
    

if __name__ == '__main__':

    # test_grabAndDisplayADC()
    pass